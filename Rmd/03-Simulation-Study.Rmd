---
output: pdf_document
editor_options: 
  chunk_output_type: console
---

# Simulation Study {#simulation}

A simulation study will be conducted in order to compare the likelihood based inference procedure, via the Nelder-Mead algorithm, with the Bayesian approach, based on the particle marginal Metropolis Hastings algorithm. The simulation setup will be closely related to the empirical application. Hence, a variation of the log-linear present-value formulation of the log price dividend ratio will be used. 

The latent state $x_n$ will be simulated according to the following process
\begin{equation}
\begin{split}
& x_0 = 3.5 \\
& x_{n} = \beta_0 + \phi x_{n-1} + \beta_{1}z_{1, n} + \beta_{2}z_{2, n} + u_{n} \\ 
& u_{n} \sim \mathcal{N}(0, \sigma_{u}^2)
\end{split}
\end{equation}
where $z_{1,n}$ and $z_{2,n}$ are exogenous covariates simulated according to
\begin{equation}
\begin{split}
& \begin{pmatrix} z_{1, 0} \\ z_{2, 0} \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \end{pmatrix} \\
& \begin{pmatrix} z_{1, n} \\ z_{2, n} \end{pmatrix} = \begin{pmatrix} z_{1, n-1} \\ z_{2, n-1} \end{pmatrix} + \begin{pmatrix} w_{1, n} \\ w_{2, n} \end{pmatrix} \\
& \begin{pmatrix} w_{1, n} \\ w_{2, n} \end{pmatrix} \sim N\bigg(\begin{pmatrix} 0 \\ 0 \end{pmatrix}, 0.000625\;I_{2}\bigg)
\end{split}
\end{equation}
Furthermore, the state process will be bound to be between the minimum (2.775) and the maximum (4.487) of the observed log priced dividend ratio.

The observation process will be simulated according to the following equation
\begin{equation}
\begin{split}
& y_{n} = \frac{k_{n}}{1 - \rho_{n}} + d_{n} +  \epsilon_{n} \\
& \epsilon_{n}\sim \mathcal{N}(0, \sigma_{\epsilon}^2)
\end{split}
\end{equation}
where $k_{t}$ and $\rho_t$ directly depend on the latent state process $x_t$ via
\begin{equation}
\begin{split}
& \rho_{n} = \frac{1}{1+\text{exp}(-x_{n})}\\
& k_{n} = -\ln(\rho_{n})-(1-\rho_{n})\ln\bigg(\frac{1}{\rho_{n}} - 1\bigg)
\end{split}
\end{equation}
and $d_{t}$ will be handled as an exogenous covariate arising from the following specification
\begin{equation}
\begin{split}
& d_{n} = -0.987 + 0.887(d_{n - 1} + 0.987) + 0.111v_{n-1} + v_{n} \\ 
& v_{n} \sim \mathcal{N}(0, 0.005)
\end{split}
\end{equation}
All in all, the processes $y_{n}$, $d_{n}$, $z_{1, n}$ and $z_{2, n}$ are observable whereas the state process $x_n$ is not. Hence, the results of the likelihood based and Bayesian approach for estimating the latent state and the parameters $\{\phi, \beta_0, \beta_{1}, \beta_{2}, \sigma_{\epsilon}, \sigma_{u}\}$ will be compared.

```{r, helper_nonlinear_simulation, include = FALSE, eval=FALSE}
generate_simulation_data <- function(n, params) {
  # simulate d_t
  d_t <- arima.sim(
    model = list(
      order = c(1, 0, 1),
      ar = 0.887,
      ma = 0.111
    ),
    n = n,
    sd = sqrt(0.00444)
  )
  d_t <- d_t - 0.987
  
  # simulate latent mean
  latent_lpd_sim <- vector("numeric", length = n)
  x_1 <- vector("numeric", length = n)
  x_2 <- vector("numeric", length = n)
  for (i in 1:n) {
    if (i == 1) {
      x_1[i] <- 0
      x_2[i] <- 0
      latent_lpd_sim[i] <- params["mu"]
    } else {
      while (TRUE) {
        val_2 <- x_1[i - 1] + rnorm(1, 0, 0.05)
        val_3 <- x_2[i - 1] + rnorm(1, 0, 0.05)
        val_1 <- (
          3.5 + tanh(params["phi"]) * (latent_lpd_sim[i - 1] - params["mu"])
          + params["beta_1"] * val_2
          + params["beta_2"] * val_3
          + rnorm(1, 0, exp(params["sigma_x"]))
        )
        if (val_1 > 2.7 & val_1 < 4.5) {
          x_1[i] <- val_2
          x_2[i] <- val_3
          latent_lpd_sim[i] <- val_1
          break
        }
      }
    }
  }
  
  # compute observed lpd
  observed_lpd <- vector("numeric", length = n)
  for (i in 1:n) {
    rho <- 1 / (1 + exp(-latent_lpd_sim[i]))
    k <- -log(rho) - ((1 - rho) * log((1 / rho) - 1))
    observed_lpd[i] <- ((k / (1 - rho)) + d_t[i]
                        + rnorm(1, 0, exp(params["sigma_y"])))
  }
  return(list(
    observed = cbind(observed_lpd, d_t, x_1, x_2),
    latent = latent_lpd_sim
  ))
}
generate_start_params <- function(params){
  return(params + rnorm(length(params), 0, 0.1))
}
```

```{r, setup_nonlinear_simulation, include = FALSE, eval=FALSE}
N <- 50
N_sim <- 100
true_params_simulation <- c(
    mu = 3.5,
    beta_1 = 0.4,
    beta_2 = -0.2,
    sigma_x = log(0.05),
    sigma_y = log(0.02),
    phi = atanh(0.85)
)
params_simulation <- c(
    mu = 3.5,
    beta_1 = 0.0,
    beta_2 = 0.0,
    sigma_x = log(0.1),
    sigma_y = log(0.05),
    phi = atanh(0.5)
)
```

```{r, test_simulation, include=FALSE, eval=FALSE}
# generate data
start_time <- Sys.time()
generated_data <- generate_simulation_data(N, true_params_simulation)

# transform to state x and process y
data <- data.frame(cbind(1:N, generated_data$observed))
colnames(data) <- c("time", "y", "d", "x1", "x2")
y <- data[, c("time", "y")]
covar <- data[, c("time", "d", "x1", "x2")]
covar_2 <- covar
covar_2[1:(N - 1), 3:4] <- covar_2[2:N, 3:4]
x <- generated_data$latent
head(y)
tail(y)

# visualize data
plot(y[, 2], type = "l")
lines(x, col = "red")
legend(
    "topleft",
    legend = c("obs", "latent"),
    col = c("black", "red"),
    lty = c(1, 1)
)

# create pomp object
pomp_simulation <- pomp::pomp(
    # init data
    data = y, times = "time", t0 = 1,
    # init process / state
    rinit = function(mu, ...){
        c(x = mu)
    },
    rprocess = pomp::discrete_time(
        pomp::Csnippet(
            "
            x = (
                mu + tanh(phi) * (x - mu) + beta_1 * x1 + beta_2 * x2
                + rnorm(0, exp(sigma_x))
            );
            "
        ), delta.t = 1
    ),
    # init meas / obs
    dmeasure = pomp::Csnippet(
        "
        double rho_t = 1.0 / (1.0 + exp(-x));
        double k_t = -log(rho_t) - ((1.0 - rho_t) * log((1.0 / rho_t) - 1.0));
        double m = (k_t / (1 - rho_t)) + d;
        lik = dnorm(y, m, exp(sigma_y), give_log);
        "
    ),
    # state names
    statenames = "x",
    # obs names
    obsnames = "y",
    # param names
    paramnames = c("beta_1", "beta_2", "mu", "sigma_x",
                   "sigma_y", "phi"),
    # covar
    covar = pomp::covariate_table(covar_2, times = "time"),
    covarnames = c("d", "x1", "x2")
)

# test optim parameter estimation
theta <- c(
    beta_1 = 0.0,
    beta_2 = 0.0,
    mu = 3.0,
    sigma_x = log(0.1),
    sigma_y = log(0.05),
    phi = atanh(0.8)
)
# can use optim only for finding MLE --> not for CI
optim_result <- replicate(
    10,
    {
        op_res <- optim(
            par = theta,
            fn = function(par){
                # print(par)
                pomp::logLik(pomp::pfilter(
                    pomp_simulation, params = par, Np = 500
                ))
            },
            control = list(
                "fnscale" = -1
            )
        )
        return(c(op_res$par, value = op_res$value))
    }
)

k <- which.max(optim_result["value", ])
(est_params <- optim_result[1:length(theta), k])
true_params_simulation

# compare pfilter result
pf1 <- pomp::pfilter(
    pomp_simulation,
    params = c(
        beta_1 = as.vector(true_params_simulation["beta_1"]),
        beta_2 = as.vector(true_params_simulation["beta_2"]),
        sigma_y = as.vector(true_params_simulation["sigma_y"]),
        sigma_x = as.vector(true_params_simulation["sigma_x"]),
        phi = as.vector(true_params_simulation["phi"]),
        mu = 3.5
    ),
    Np = 500,
    filter.mean = TRUE
)
pomp::logLik(pf1)

pf2 <- pomp::pfilter(
    pomp_simulation,
    params = est_params,
    Np = 500,
    filter.mean = TRUE
)
pomp::logLik(pf2)

# pmcmc test - noninformative prior
pmcmc_noninformative <- pomp::pmcmc(
    pomp_simulation,
    Nmcmc = 6000,
    Np = 500,
    proposal = pomp::mvn.diag.rw(
        c(mu = 0.03, sigma_x = 0.03, sigma_y = 0.03, beta_1 = 0.03,
          beta_2 = 0.03, phi = 0.03)
    ),
    params = theta,
    verbose = FALSE
)

# pmcmc test - informative prior
pmcmc_informative <- pomp::pmcmc(
    pomp_simulation,
    Nmcmc = 6000,
    Np = 500,
    proposal = pomp::mvn.diag.rw(
        c(mu = 0.03, sigma_x = 0.03, sigma_y = 0.03, beta_1 = 0.03,
          beta_2 = 0.03, phi = 0.03)
    ),
    params = theta,
    verbose = FALSE,
    dprior = function(mu, sigma_x, sigma_y, beta_1, beta_2, phi, ..., log){
      p_mu <- dnorm(mu, 3.5, 0.2)
      p_sigma_x <- dnorm(sigma_x, log(0.06), 0.5)
      p_sigma_y <- dnorm(sigma_y, log(0.04), 0.5)
      p_beta_1 <- dnorm(beta_1, 0.5, 0.5)
      p_beta_2 <- dnorm(beta_2, -0.3, 0.5)
      p_phi <- dnorm(phi, atanh(0.75), 0.3)
      lik <- (
        p_mu * p_sigma_x * p_sigma_y * p_beta_1 * p_beta_2 * p_phi
      )
      return(ifelse(log, log(lik), lik))
    }
)
end_time <- Sys.time()
print(end_time - start_time)
```

```{r, nonlinear_simulation, include = FALSE, eval=FALSE}
nonlinear_simulation <- function(N_obs, true_params, start_params) {
  data_simulation <- generate_simulation_data(N_obs, true_params)
  theta <- generate_start_params(start_params)
  
  # transform to state x and process y
  data <- data.frame(cbind(1:N, data_simulation$observed))
  colnames(data) <- c("time", "y", "d", "x1", "x2")
  y <- data[, c("time", "y")]
  covar <- data[, c("time", "d", "x1", "x2")]
  covar_2 <- covar
  covar_2[1:(N - 1), 3:4] <- covar_2[2:N, 3:4]

  # create pomp object
  pomp_simulation <- pomp::pomp(
      # init data
      data = y, times = "time", t0 = 1,
      # init process / state
      rinit = function(mu, ...){
          c(x = mu)
      },
      rprocess = pomp::discrete_time(
          pomp::Csnippet(
              "
              x = (
                  mu + tanh(phi) * (x - mu) + beta_1 * x1 + beta_2 * x2
                  + rnorm(0, exp(sigma_x))
              );
              "
          ), delta.t = 1
      ),
      # init meas / obs
      dmeasure = pomp::Csnippet(
          "
          double rho_t = 1.0 / (1.0 + exp(-x));
          double k_t = -log(rho_t) - ((1.0 - rho_t) * log((1.0 / rho_t) - 1.0));
          double m = (k_t / (1 - rho_t)) + d;
          lik = dnorm(y, m, exp(sigma_y), give_log);
          "
      ),
      # state names
      statenames = "x",
      # obs names
      obsnames = "y",
      # param names
      paramnames = c("beta_1", "beta_2", "mu", "sigma_x",
                     "sigma_y", "phi"),
      # covar
      covar = pomp::covariate_table(covar_2, times = "time"),
      covarnames = c("d", "x1", "x2")
  )

  # can use optim only for finding MLE --> not for CI
  optim_result <- replicate(
      10,
      {
          op_res <- optim(
              par = theta,
              fn = function(par){
                  # print(par)
                  pomp::logLik(pomp::pfilter(
                      pomp_simulation, params = par, Np = 500
                  ))
              },
              control = list(
                  "fnscale" = -1
              )
          )
          return(c(op_res$par, value = op_res$value))
      }
  )

  k <- which.max(optim_result["value", ])
  est_params <- optim_result[1:length(theta), k]
  pf <- pomp::pfilter(
    pomp_simulation, params = est_params, Np = 500, filter.mean = TRUE
  )
  
  pmmh_noninformative <- pomp::pmcmc(
      pomp_simulation,
      Nmcmc = 6000,
      Np = 500,
      proposal = pomp::mvn.diag.rw(
          c(mu = 0.03, sigma_x = 0.03, sigma_y = 0.03, beta_1 = 0.03,
            beta_2 = 0.03, phi = 0.03)
      ),
      params = theta,
      verbose = FALSE
  )
  
  pmmh_informative <- pomp::pmcmc(
      pomp_simulation,
      Nmcmc = 6000,
      Np = 500,
      proposal = pomp::mvn.diag.rw(
          c(mu = 0.03, sigma_x = 0.03, sigma_y = 0.03, beta_1 = 0.03,
            beta_2 = 0.03, phi = 0.03)
      ),
      params = theta,
      verbose = FALSE,
      dprior = function(mu, sigma_x, sigma_y, beta_1, beta_2, phi, ..., log){
          p_mu <- dnorm(mu, 3.5, 0.2)
          p_sigma_x <- dnorm(sigma_x, log(0.06), 0.5)
          p_sigma_y <- dnorm(sigma_y, log(0.04), 0.5)
          p_beta_1 <- dnorm(beta_1, 0.5, 0.25)
          p_beta_2 <- dnorm(beta_2, -0.3, 0.25)
          p_phi <- dnorm(phi, atanh(0.75), 0.3)
          lik <- (
            p_mu * p_sigma_x * p_sigma_y * p_beta_1 * p_beta_2 * p_phi
          )
          return(ifelse(log, log(lik), lik))
      }
  )
  
  return(
    list(
      data_observed = data_simulation$observed,
      data_latent = data_simulation$latent,
      theta = theta,
      smc_result = list(par = est_params, pf = pf),
      pmmh_noninformative = pmmh_noninformative,
      pmmh_informative = pmmh_informative
    )
  )
}

# bake this stuff
system.time(
  simulation_result <- pomp::bake(
    "simulation_study_result.rds",
    {
      doRNG::registerDoRNG(1598260027L)
      cl <- parallel::makeCluster(4)
      doParallel::registerDoParallel(cl)
      results <- foreach::`%dopar%`(
        foreach::foreach(i = 1:N_sim),
        nonlinear_simulation(N, true_params_simulation, params_simulation)
      )
      parallel::stopCluster(cl)
      results
    }
  )
)
```

```{r, simulation_result_plots, eval=FALSE}
res_smc <- matrix(nrow = N_sim, ncol = length(params_simulation))
res_pmmh_noninformative <- matrix(
  nrow = N_sim, ncol = length(params_simulation)
)
res_pmmh_informative <- matrix(nrow = N_sim, ncol = length(params_simulation))

for (i in 1:N_sim) {
    res_smc[i, ] <- simulation_result[[i]]$smc_result$par
    for (j in 1:length(params_simulation)) {
        res_pmmh_informative[i, j] <- mean(
          simulation_result[[i]]$pmmh_informative@traces[2000:6000, j+2]
        )
        res_pmmh_noninformative[i, j] <- mean(
          simulation_result[[i]]$pmmh_noninformative@traces[2000:6000, j+2]
        )
    }
}

# smc result
plot(density(res_smc[, 1]), type = "l")
plot(density(res_smc[, 2]), type = "l")
plot(density(res_smc[, 3]), type = "l")
plot(density(exp(res_smc[, 4])), type = "l")

# pmmh result
plot(density(res_pmmh_noninformative[, 1]), type = "l")
plot(density(res_pmmh[, 2]), type = "l")
plot(density(res_pmmh[, 3]), type = "l")
plot(density(res_pmmh[, 4]), type = "l")
```

