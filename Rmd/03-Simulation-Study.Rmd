---
output: pdf_document
editor_options: 
  chunk_output_type: console
---

# Simulation Study {#simulation}

**Content:**

- Linear and Nonlinear Model example

- Simulation for presenting benefits of the bayesian framework 

    - compare with weak and informative priors and the particle filter itself and also Kalman Filter in the linear case


## Nonlinear Simulation

**Observation:**

$$\rho_{t} = \frac{1}{1+exp(-\tilde{\eta_{t}})}$$

$$k_{t} = -ln(\rho_{t})-(1-\rho_{t})ln\bigg(\frac{1}{\rho_{t}} - 1\bigg)$$

$$d_{t} = -0.987 + 0.887(d_{t - 1} + 0.987) + 0.111v_{t-1} + v_{t}$$
$$v_{t} \sim N(0, 0.00444)$$


$$\eta_{t} = \frac{k_{t}}{1 - \rho_{t}} + d_{t} +  \epsilon_{t}$$

$$\epsilon_{t} \sim N(0, \sigma_{\epsilon}^2)$$

**State:**

$$\tilde{\eta}_{t} = \beta_{1}x_{1, t-1} + \beta_{2}x_{2, t-1} + u_{t}$$
$$u_{t} \sim N(0, \sigma_{u}^2)$$

$$x_{1, t} = x_{1, t - 1} + z_{1, t}$$
$$x_{2, t} = x_{2, t - 1} + z_{2, t}$$

$$\begin{pmatrix} z_{1, t} \\ z_{2, t} \end{pmatrix} \sim N(0, 0.000625\;I_{2})$$
- $\eta_{t}$, $d_{t}$, $x_{1, t}$, $x_{2, t}$ are observed

- $\tilde{\eta}_{t}$ is not observed

- $\{\beta_{1}, \beta_{2}, \sigma_{\epsilon}, \sigma_{u}\}$ need to be estimated

- $\tilde{\eta}_{t}$ is bound to be between 2.9 and 4.35

```{r, source_basic_functions, include=FALSE, eval=FALSE}
source(here::here("R", "particle_filter_functions.R"))
source(here::here("R", "smc_nonlinear_simulation.R"))
source(here::here("R", "pmmh_nonlinear_simulation.R"))
```

```{r, helper_nonlinear_simulation, include = FALSE, eval=FALSE}
generate_simulation_data <- function(n, params) {
  # simulate d_t
  d_t <- arima.sim(
    model = list(
      order = c(1, 0, 1),
      ar = 0.887,
      ma = 0.111
    ),
    n = n,
    sd = sqrt(0.00444)
  )
  d_t <- d_t - 0.987
  
  # simulate latent mean
  latent_lpd_sim <- vector("numeric", length = n)
  x_1 <- vector("numeric", length = n)
  x_2 <- vector("numeric", length = n)
  for (i in 1:n) {
    if (i == 1) {
      x_1[i] <- 0
      x_2[i] <- 0
      latent_lpd_sim[i] <- 3.5
    } else {
      while (TRUE) {
        val_2 <- x_1[i - 1] + rnorm(1, 0, 0.05)
        val_3 <- x_2[i - 1] + rnorm(1, 0, 0.05)
        val_1 <- (
          3.5 + params["phi"] * (latent_lpd_sim[i - 1] - 3.5)
          + params["beta_1"] * val_2
          + params["beta_2"] * val_3
          + rnorm(1, 0, exp(params["sigma_x"]))
        )
        if (val_1 > 2.7 & val_1 < 4.5) {
          x_1[i] <- val_2
          x_2[i] <- val_3
          latent_lpd_sim[i] <- val_1
          break
        }
      }
    }
  }
  
  # compute observed lpd
  observed_lpd <- vector("numeric", length = n)
  for (i in 1:n) {
    rho <- 1 / (1 + exp(-latent_lpd_sim[i]))
    k <- -log(rho) - ((1 - rho) * log((1 / rho) - 1))
    observed_lpd[i] <- ((k / (1 - rho)) + d_t[i]
                        + rnorm(1, 0, exp(params["sigma_y"])))
  }
  return(list(
    observed = cbind(observed_lpd, d_t, x_1, x_2),
    latent = latent_lpd_sim
  ))
}
```

```{r, setup_nonlinear_simulation, include = FALSE, eval=FALSE}
N_obs <- 100
N_sim <- 4
true_params_simulation <- c(
    beta_1 = 0.8,
    beta_2 = 0.2,
    sigma_e = log(0.015),
    sigma_u = log(0.05),
    phi = 0.8
)
params_simulation <- c(
    beta_1 = 1.0,
    beta_2 = 0.5,
    sigma_e = log(0.1),
    sigma_u = log(0.05)
)
```

```{r, test_simulation, include=FALSE, eval=FALSE}
data_simulation <-
  generate_simulation_data(N_obs, true_params_simulation)

# smc find parameters
smc_result <- optim(
  params_simulation,
  method = "Nelder-Mead",
  fn = function(par, ...) {
    smc(par, ...)$prob
  },
  y = data_simulation$observed,
  n_particles = 500,
  start_point = 2,
  prob_state = prob_state_simulation_nonlinear,
  sample_state = sample_state_simulation_nonlinear,
  n_states = 1,
  more_information = TRUE,
  hessian = FALSE
)

smc_simulation <- smc(
  smc_result$par,
  y = data_simulation$observed,
  n_particles = 500,
  start_point = 2,
  prob_state = prob_state_simulation_nonlinear,
  sample_state = sample_state_simulation_nonlinear,
  n_states = 1
)

# pmmh noninformative
pmmh_result <- pmmh(
  params = params_simulation,
  y = data_simulation$observed,
  start_point = 2,
  prob_state = prob_state_simulation_nonlinear,
  sample_state = sample_state_simulation_nonlinear,
  likelihood_prior = likli_prior_nl_sim_ui,
  proposal = proposal_nl_sim_ui,
  likelihood_proposal = likli_proposal_nl_sim_ui,
  n_states = 1,
  n_met = 2500,
  n_particles = 250,
  burn_in = 0,
  thining = 1,
  more_information = TRUE
)

plot(data_simulation$observed[2:N_obs, 1], type = "l")
lines(data_simulation$latent[2:N_obs], col = "green")
lines(smc_simulation$state[1, , 1], col = "red")
lines(colMeans(pmmh_result$paths[1000:2000, ]), col = "blue")
```

```{r, nonlinear_simulation, include = FALSE, eval=FALSE}
nonlinear_simulation <- function(N_obs, true_params, start_params) {
  data_simulation <- generate_simulation_data(N_obs, true_params)
  
  # smc find parameters
  smc_result <- optim(
    start_params,
    method = "Nelder-Mead",
    fn = function(par, ...) {
      smc(par, ...)$prob
    },
    y = data_simulation$observed,
    n_particles = 500,
    start_point = 2,
    prob_state = prob_state_simulation_nonlinear,
    sample_state = sample_state_simulation_nonlinear,
    n_states = 1,
    more_information = FALSE,
    hessian = FALSE
  )
  
  # smc find states
  smc_simulation <- smc(
    smc_result$par,
    y = data_simulation$observed,
    n_particles = 500,
    start_point = 2,
    prob_state = prob_state_simulation_nonlinear,
    sample_state = sample_state_simulation_nonlinear,
    n_states = 1
  )
  
  # pmmh noninformative
  pmmh_result <- pmmh(
    params = start_params,
    y = data_simulation$observed,
    start_point = 2,
    prob_state = prob_state_simulation_nonlinear,
    sample_state = sample_state_simulation_nonlinear,
    likelihood_prior = likli_prior_nl_sim_ui,
    proposal = proposal_nl_sim_ui,
    likelihood_proposal = likli_proposal_nl_sim_ui,
    n_states = 1,
    n_met = 2000,
    n_particles = 250,
    burn_in = 0,
    thining = 1,
    more_information = FALSE
  )
  return(
    list(
      data_observed = data_simulation$observed,
      data_latent = data_simulation$latent,
      smc_result = list(par = smc_result$par, 
                        state = smc_simulation$state[1, , 1]),
      pmmh_result = pmmh_result
    )
  )
}

cl <- parallel::makeCluster(4)
doParallel::registerDoParallel(cl)
system.time(results <- foreach::`%dopar%`(
  foreach::foreach(i = 1:N_sim),
  nonlinear_simulation(N_obs, true_params_simulation, params_simulation)
))
parallel::stopCluster(cl)
```

```{r, simulation_result_plots, eval=FALSE}
res_smc <- matrix(nrow = N_sim, ncol = 4)
res_pmmh <- matrix(nrow = N_sim, ncol = 4)

for (i in 1:N_sim) {
    res_smc[i, ] <- results[[i]]$smc_result$par
    for (j in 1:4) {
        if (j <= 2) {
            d <- density(results[[i]]$pmmh_result$theta[, j])
            res_pmmh[i, j] <- d$x[which.max(d$y)]
        } else {
            d <- density(exp(results[[i]]$pmmh_result$theta[, j]))
            res_pmmh[i, j] <- d$x[which.max(d$y)]
        }
        
    }
}

# smc result
plot(density(res_smc[, 1]), type = "l")
plot(density(res_smc[, 2]), type = "l")
plot(density(exp(res_smc[, 3])), type = "l")
plot(density(exp(res_smc[, 4])), type = "l")

# pmmh result
plot(density(res_pmmh[, 1]), type = "l")
plot(density(res_pmmh[, 2]), type = "l")
plot(density(res_pmmh[, 3]), type = "l")
plot(density(res_pmmh[, 4]), type = "l")
```

**Setup:**

